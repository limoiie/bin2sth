import json

from pymongo import MongoClient

from src.corpus import Corpus
from src.ida.code_elements import Serializable, Program, Arch
from src.preprocess import AsmVocab, CBowDataEnd
from src.preprocess import DIProxy, DIPure, DIStmts
from src.preprocess import DITokenizer, DIUnite
from src.utils.filter_collection import filter_dict
from src.utils.list_joint import flat, joint_list


def get_database_client():
    client = MongoClient('localhost', 27017)
    return client


def load_json_file(file):
    with open(file, 'r') as f:
        return json.load(f)


def parser_program_info(json_file):
    """ 
    Parser the instance of Program from the given json file, which 
    is generated by ida pro script
    """
    return Serializable.load(json_file, Program)


def parser_program_info_json(json_file):
    """ 
    Parser the Program into dict from the given json file, which 
    is generated by ida pro script
    """
    return load_json_file(json_file)


def make_prog_filter(p=None, pv=None, c=None, cv=None, arch=None,
                     opt=None, obf=None):
    prog = Program((p, pv), (c, cv), arch, opt, obf)
    the_filter = prog.serialize()
    return filter_dict(the_filter)


def load_progs(db, **args):
    the_filter = make_prog_filter(**args)
    return db.binaries.find(the_filter)


def load_one_prog(db, **args):
    for prog in load_progs(db, **args):
        return prog
    return None


class BinArgs(Serializable):
    def __init__(self, progs=None, prog_vers=None, ccs=None, cc_vers=None,
                 archs=None, opts=None, obfs=None):
        self.progs, self.prog_vers = progs, prog_vers
        self.ccs, self.cc_vers = ccs, cc_vers
        self.archs, self.opts, self.obfs = archs, opts, obfs

    def joint(self):
        """ Joint product the args to form a set of binaries """
        progs = flat(self.progs, self.prog_vers)
        ccs = flat(self.ccs, self.cc_vers)
        return joint_list([progs, ccs, self.archs, self.opts, self.obfs])
    
    def serialize(self):
        dic = super(BinArgs, self).serialize()
        dic['archs'] = self.to_json_list(self.archs)
        return dic

    def deserialize(self, data):
        super(BinArgs, self).deserialize(data)
        self.archs = self.from_json_list(Arch, data['archs'])
        return self


def load_progs_joint(db, args: BinArgs):
    """ 
    Joint product the args to form a set of binaries and then load the 
    info of these binaries into a list.
    """
    prog_info_jsons = []
    for (prog, prog_ver), (cc, cc_ver), arch, opt, obf in args.joint():
        p = load_one_prog(db, p=prog, pv=prog_ver, c=cc, cv=cc_ver,
                          arch=arch, opt=opt, obf=obf)
        if p is None:
            raise ValueError(f'No such Program info in the database: \
                prog={prog}, prog_ver={prog_ver}, cc={cc}, cc_ver={cc_ver}, \
                arch={arch}, opt={opt}, obf={obf}')
        prog_info_jsons.append(p)
    return prog_info_jsons


def load_vocab(db, args: BinArgs):
    # TODO: cache into db
    progs = load_progs_joint(db, args)
    pp = DIProxy([DIPure(), DITokenizer(), DIStmts(), DIUnite()])
    docs = pp.per(progs)
    vocab = AsmVocab()
    vocab.build(docs)
    return vocab


def load_corpus(db, args: BinArgs):
    progs = load_progs_joint(db, args)    
    pp = DIProxy([DIPure(), DITokenizer(), DIUnite()])
    docs = pp.per(progs)
    corpus = Corpus()
    corpus.build(docs)
    return corpus


def load_cbow_data_end(db, vocab_args, args: BinArgs, window):
    # TODO: cache into db
    vocab = load_vocab(db, vocab_args)
    corpus = load_corpus(db, args)
    data = CBowDataEnd(window, vocab, corpus)
    data.build()
    return data
